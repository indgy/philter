{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"A PHP fluent input sanitiser. Philter accepts untrusted input, passes it through some filters and returns it back to you. It is not a substitution for validation. Installation Copy the src/Philter.php file to your project, or install using composer: composer require indgy/philter Getting started Create a new Philter instance passing in the untrusted input, then combine filters for the untrusted input to pass through and finally call toFloat() , toInt() or toString() to get the filtered and now trusted input. use \\Indgy\\Philter; $f = new Philter($unsafe_input); $str = $f->in(['safe','string','options']) ->default('safe') ->toString(); There is also a handy shortcut function to return a new Philter instance: use function \\Indgy\\philter; $str = philter($unsafe_input) ->in(['safe','string','options']) ->default('safe') ->toString(); Refer to the Reference to view the available filters. Custom filters Define custom filters using the apply() method with a closure. The closure will be passed the current input value and expects it, or null to be returned. philter('Here we go.. ')->apply(function($v) { // do your thing here $v = $v.= 'I was philtered'; // always return $v or null return $v; })->toString(); Documentation Refer to the user guide or browse the API .","title":"Introduction"},{"location":"#a-php-fluent-input-sanitiser","text":"Philter accepts untrusted input, passes it through some filters and returns it back to you. It is not a substitution for validation.","title":"A PHP fluent input sanitiser."},{"location":"#installation","text":"Copy the src/Philter.php file to your project, or install using composer: composer require indgy/philter","title":"Installation"},{"location":"#getting-started","text":"Create a new Philter instance passing in the untrusted input, then combine filters for the untrusted input to pass through and finally call toFloat() , toInt() or toString() to get the filtered and now trusted input. use \\Indgy\\Philter; $f = new Philter($unsafe_input); $str = $f->in(['safe','string','options']) ->default('safe') ->toString(); There is also a handy shortcut function to return a new Philter instance: use function \\Indgy\\philter; $str = philter($unsafe_input) ->in(['safe','string','options']) ->default('safe') ->toString(); Refer to the Reference to view the available filters.","title":"Getting started"},{"location":"#custom-filters","text":"Define custom filters using the apply() method with a closure. The closure will be passed the current input value and expects it, or null to be returned. philter('Here we go.. ')->apply(function($v) { // do your thing here $v = $v.= 'I was philtered'; // always return $v or null return $v; })->toString();","title":"Custom filters"},{"location":"#documentation","text":"Refer to the user guide or browse the API .","title":"Documentation"},{"location":"reference/","text":"Reference Return methods Philter will apply each filter and return the required scalar type by calling the to*() methods, call one of these methods after you have specified your filters: toString() \"abcc-123.456\" = philter(\"abc-123.456\")->toString(); toInt() 123 = philter(\"123.456\")->toInt(); toFloat() 123.456 === philter(\"123.456\")->toFloat(); toBool() true === philter(\"1\")->toBool(); The input is never modified so it is possible to reuse filters and return a different type: $filter = philter(\"1\")->digits(); \"1\" === $filter->toString(); true === $filter->toBool(); Returning a default value If the input does not pass through a filter, a null value will be returned to the to*() method. Use the default() method to specify a default value to return; String filters The following filters accept any string or numeric input. allow() Removes any characters that are not in the allow list, pass the allowed characters as a regex: \"abccc\" = philter(\"abcccdef\")->allow(\"a-c\")->toString(); ascii() Replaces any non ASCII characters with a non accented approximation: \"creme brulee\" = philter(\"cr\u00e8me br\u00fbl\u00e9e\")->ascii()->toString(); alpha() Removes any non alphabetical characters: \"abc\" = philter(\"abc 123\")->alpha()->toString(); Pass in additional allowed characters as the first argument: \"abc 2\" = philter(\"abc 123\")->alpha(\"2\\s\")->toString(); alphanum() Removes any non alpha-numeric characters: \"abc123\" = philter(\"abc-123\")->alphanum()->toString(); Pass in additional allowed characters as the first argument: \"abc-123\" = philter(\"abc-1,2,3\")->alpha(\"-\")->toString(); contains() Checks that the variable contains the string in \\$match: \"This will pass\" = philter(\"This will pass\")->contains(\"this\")->toString(); By default this is not case sensitive, pass a Boolean true to match case: null = philter(\"This will not pass\")->contains(\"this\", true)->toString(); cut() Shortens the length to \\$len characters $str = \"This string is probably too long to be a title and will probably break the designers page layout\"; \"This string is\" = philter($str)->cut(15)->trim()->toString(); digits() A stricter version of numeric, this removes any non numeric characters allowing only 0-9 and decimal point: 123 = philter(\"abc-123.456\")->digits()->toInt(); 123.456 = philter(\"abc-123.456\")->digits()->toFloat(); \"123.456\" = philter(\"abc-123.456\")->digits()->toString(); Pass in additional allowed characters as the first argument: \"+15556677\" = philter(\"+1 555 6677\")->digits(\"+\\s\")->toString(); email() Removes any characters that should not be in an email address: \"user@example.com\" = philter(\"[user]@!!example!!.com\")->email()->toString(); Note: This is a simple filter, but probably stricter than the built in filter_var() method in() Ensures the input matches a value contained in the array: \"date\" = philter(\"date\")->in([\"id\",\"date\",\"status\"])->toString(); By default this is not case sensitive, pass a Boolean true to match case: null = philter(\"date\")->in([\"Id\",\"Date\",\"Status\"], true)->toString(); Use default() to return a default value if not matched: \"date\" = philter(\"price\")->in([\"id\",\"date\",\"status\"])->default(\"date\")->toString(); numeric() Removes any non numeric characters allowing common number markup such as + or - decimal points, commas, brackets and spaces: \"+(1) 555 4567\" = philter(\"+(1) 555 4567\")->numeric()->toString(); Pass in additional allowed characters as the first argument: \"+(1) 555-4567\" = philter(\"+1 555-6677\")->numeric(\"-\")->toString(); trim() See also ltrim() and rtrim() Trims the leading and trailing characters from the variable: \"abcdef\" = philter(\" abcdef \")->trim()->toString(); Pass in the character to trim as the first argument: \"abcdef\" = philter(\"/abcdef/\")->trim(\"/\")->toString(); Numeric filters The following filters expect the input to be numeric. between() Ensures the input is a value between \\$min and \\$max 45 = philter(\"45\")->between(1, 100)->toInt(); min() Ensures the input is no less than the value of \\$min 15 = philter(\"15\")->min(10)->toInt(); max() Ensures the input is no greater than the value of \\$max 95 = philter(\"95\")->max(100)->toInt(); HTML filters The following filters handle HTML filtering. stripHtml() Removes all HTML: \"Hello world!\" = philter(\"<h1>Hello world!</h1>\")->stripHtml()->toString(); stripTags() Removes the majority of HTML tags and javascript leaving the basic tags: \"<h1>Hello world!</h1>\" = philter(\"<h1>Hello world!</h1><script>doSomething():</script>\")->stripHtml()->toString(); stripAttributes() Removes all attributes from HTML tags: \"<h1>Hello world!</h1>\" = philter(\"<h1 class='big red'>Hello world!</h1>\")->stripAttributes()->toString();","title":"Reference"},{"location":"reference/#reference","text":"","title":"Reference"},{"location":"reference/#return-methods","text":"Philter will apply each filter and return the required scalar type by calling the to*() methods, call one of these methods after you have specified your filters:","title":"Return methods"},{"location":"reference/#tostring","text":"\"abcc-123.456\" = philter(\"abc-123.456\")->toString();","title":"toString()"},{"location":"reference/#toint","text":"123 = philter(\"123.456\")->toInt();","title":"toInt()"},{"location":"reference/#tofloat","text":"123.456 === philter(\"123.456\")->toFloat();","title":"toFloat()"},{"location":"reference/#tobool","text":"true === philter(\"1\")->toBool(); The input is never modified so it is possible to reuse filters and return a different type: $filter = philter(\"1\")->digits(); \"1\" === $filter->toString(); true === $filter->toBool();","title":"toBool()"},{"location":"reference/#returning-a-default-value","text":"If the input does not pass through a filter, a null value will be returned to the to*() method. Use the default() method to specify a default value to return;","title":"Returning a default value"},{"location":"reference/#string-filters","text":"The following filters accept any string or numeric input.","title":"String filters"},{"location":"reference/#allow","text":"Removes any characters that are not in the allow list, pass the allowed characters as a regex: \"abccc\" = philter(\"abcccdef\")->allow(\"a-c\")->toString();","title":"allow()"},{"location":"reference/#ascii","text":"Replaces any non ASCII characters with a non accented approximation: \"creme brulee\" = philter(\"cr\u00e8me br\u00fbl\u00e9e\")->ascii()->toString();","title":"ascii()"},{"location":"reference/#alpha","text":"Removes any non alphabetical characters: \"abc\" = philter(\"abc 123\")->alpha()->toString(); Pass in additional allowed characters as the first argument: \"abc 2\" = philter(\"abc 123\")->alpha(\"2\\s\")->toString();","title":"alpha()"},{"location":"reference/#alphanum","text":"Removes any non alpha-numeric characters: \"abc123\" = philter(\"abc-123\")->alphanum()->toString(); Pass in additional allowed characters as the first argument: \"abc-123\" = philter(\"abc-1,2,3\")->alpha(\"-\")->toString();","title":"alphanum()"},{"location":"reference/#contains","text":"Checks that the variable contains the string in \\$match: \"This will pass\" = philter(\"This will pass\")->contains(\"this\")->toString(); By default this is not case sensitive, pass a Boolean true to match case: null = philter(\"This will not pass\")->contains(\"this\", true)->toString();","title":"contains()"},{"location":"reference/#cut","text":"Shortens the length to \\$len characters $str = \"This string is probably too long to be a title and will probably break the designers page layout\"; \"This string is\" = philter($str)->cut(15)->trim()->toString();","title":"cut()"},{"location":"reference/#digits","text":"A stricter version of numeric, this removes any non numeric characters allowing only 0-9 and decimal point: 123 = philter(\"abc-123.456\")->digits()->toInt(); 123.456 = philter(\"abc-123.456\")->digits()->toFloat(); \"123.456\" = philter(\"abc-123.456\")->digits()->toString(); Pass in additional allowed characters as the first argument: \"+15556677\" = philter(\"+1 555 6677\")->digits(\"+\\s\")->toString();","title":"digits()"},{"location":"reference/#email","text":"Removes any characters that should not be in an email address: \"user@example.com\" = philter(\"[user]@!!example!!.com\")->email()->toString(); Note: This is a simple filter, but probably stricter than the built in filter_var() method","title":"email()"},{"location":"reference/#in","text":"Ensures the input matches a value contained in the array: \"date\" = philter(\"date\")->in([\"id\",\"date\",\"status\"])->toString(); By default this is not case sensitive, pass a Boolean true to match case: null = philter(\"date\")->in([\"Id\",\"Date\",\"Status\"], true)->toString(); Use default() to return a default value if not matched: \"date\" = philter(\"price\")->in([\"id\",\"date\",\"status\"])->default(\"date\")->toString();","title":"in()"},{"location":"reference/#numeric","text":"Removes any non numeric characters allowing common number markup such as + or - decimal points, commas, brackets and spaces: \"+(1) 555 4567\" = philter(\"+(1) 555 4567\")->numeric()->toString(); Pass in additional allowed characters as the first argument: \"+(1) 555-4567\" = philter(\"+1 555-6677\")->numeric(\"-\")->toString();","title":"numeric()"},{"location":"reference/#trim","text":"See also ltrim() and rtrim() Trims the leading and trailing characters from the variable: \"abcdef\" = philter(\" abcdef \")->trim()->toString(); Pass in the character to trim as the first argument: \"abcdef\" = philter(\"/abcdef/\")->trim(\"/\")->toString();","title":"trim()"},{"location":"reference/#numeric-filters","text":"The following filters expect the input to be numeric.","title":"Numeric filters"},{"location":"reference/#between","text":"Ensures the input is a value between \\$min and \\$max 45 = philter(\"45\")->between(1, 100)->toInt();","title":"between()"},{"location":"reference/#min","text":"Ensures the input is no less than the value of \\$min 15 = philter(\"15\")->min(10)->toInt();","title":"min()"},{"location":"reference/#max","text":"Ensures the input is no greater than the value of \\$max 95 = philter(\"95\")->max(100)->toInt();","title":"max()"},{"location":"reference/#html-filters","text":"The following filters handle HTML filtering.","title":"HTML filters"},{"location":"reference/#striphtml","text":"Removes all HTML: \"Hello world!\" = philter(\"<h1>Hello world!</h1>\")->stripHtml()->toString();","title":"stripHtml()"},{"location":"reference/#striptags","text":"Removes the majority of HTML tags and javascript leaving the basic tags: \"<h1>Hello world!</h1>\" = philter(\"<h1>Hello world!</h1><script>doSomething():</script>\")->stripHtml()->toString();","title":"stripTags()"},{"location":"reference/#stripattributes","text":"Removes all attributes from HTML tags: \"<h1>Hello world!</h1>\" = philter(\"<h1 class='big red'>Hello world!</h1>\")->stripAttributes()->toString();","title":"stripAttributes()"}]}